#version 430
layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;

uniform vec3 SphereLocation;

struct Options
{
	int width;
	int height;
	int fov;
	vec4 backgroundColour;
	ivec2 pixelCoords;
};

struct Sphere
{
	vec3 position;
	float radius;
	vec3 colour;
};

struct Plane
{
	vec3 corners[4];
	vec3 normal;
	vec4 colour;
};

uniform int totalSpheres;
uniform Sphere uSpheres[2];

// Turns degrees to radians
float ToRadians(float _degrees)
{
	return _degrees * 3.14159265359 / 180.0f;
}

// Casts a ray given origin and direction
vec3 CastRay(vec3 _origin, vec3 _direction)
{
	for(int i = 0; i < 2; i++)
	{
		// Check sphere collision
		vec3 omc = _origin - uSpheres[i].position;
		float b = dot(_direction, omc);
		float c = dot(omc, omc) - uSpheres[i].radius * uSpheres[i].radius;
		float bsqmc = b * b - c;

		// hit one or both sides
		if (bsqmc >= 0.0) 
		{
			return uSpheres[i].colour;
		}
	}
	return vec3(0.6, 0.85, 0.92);
}

void Render(Options _options) {

	// Image aspect ratio
	float aspectRatio = _options.width/_options.height;
	// Scale
	float scale = tan(ToRadians(_options.fov * 0.5)); 
	// Origin
	vec3 origin = vec3(0.0f);

	// Normalized device coordinates (NDC Space)
	float pixelNDCX = (_options.pixelCoords.x + 0.5)/_options.width;
	float pixelNDCY = (_options.pixelCoords.y + 0.5)/_options.height;
	// Generate primary ray direction
	float x = (2 * pixelNDCX - 1) * aspectRatio * scale;
	float y = (1 - 2 * pixelNDCY) * aspectRatio * scale;

	// Direction
	vec3 rayDirection = normalize(vec3(x, y, -1));

//	// Get ray origin
//	vec3 rayOrigin = CameraPosition;
//	// Get ray direction
//	vec3 rayDirection = normalize(pixelCameraSpace - CameraPosition);
//	float max_x = 5.0;
//	float max_y = 5.0;
//	ivec2 dims = imageSize(img_output); // fetch image dimensions
//	float x = (float(pixel_coords.x * 2 - dims.x) / dims.x);
//	float y = (float(pixel_coords.y * 2 - dims.y) / dims.y);
//	vec3 ray_o = vec3(x * max_x, y * max_y, 0.0);
//	vec3 ray_d = vec3(0.0, 0.0, -1.0); // ortho

	Sphere sphere;
	sphere.position = uSpheres[0].position;
	sphere.radius = uSpheres[0].radius;

	vec4 pixel = vec4(CastRay(origin, rayDirection), 1.0f);
  
	// output to a specific pixel in the image
	imageStore(img_output, _options.pixelCoords, pixel);
}

void main()
{
	// Get image dimensions
	ivec2 imageDimensions = imageSize(img_output);
	Options options;
	options.width = imageDimensions.x;
	options.height = imageDimensions.y;
	options.fov = 90;
	options.backgroundColour = vec4(0.6, 0.85, 0.92, 1.0);
	options.pixelCoords = ivec2(gl_GlobalInvocationID.xy);
	Render(options);

}